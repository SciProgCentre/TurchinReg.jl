<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User&#39;s Guide · StatReg.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StatReg.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../getting_started/">Getting started</a></li><li class="current"><a class="toctext" href>User&#39;s Guide</a><ul class="internal"><li><a class="toctext" href="#Kernel-1">Kernel</a></li><li><a class="toctext" href="#Basis-1">Basis</a></li><li><a class="toctext" href="#Gaussian-noise-distribution-with-alpha-as-argmax-of-posterior-probability-1">Gaussian noise distribution with alpha as argmax of posterior probability</a></li><li><a class="toctext" href="#Any-othes-noise-distribution-with-alpha-as-argmax-of-posterior-probability-1">Any othes noise distribution with alpha as argmax of posterior probability</a></li><li><a class="toctext" href="#Result-1">Result</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>User&#39;s Guide</a></li></ul><a class="edit-page" href="https://github.com/mipt-npm/StatReg.jl/blob/master/docs/src/users_guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>User&#39;s Guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User&#39;s-Guide-1" href="#User&#39;s-Guide-1">User&#39;s Guide</a></h1><h2><a class="nav-anchor" id="Kernel-1" href="#Kernel-1">Kernel</a></h2><p>Kernel can be specified as a matrix or as a function. Initialize a kernel as a function:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="getOpticsKernels-Tuple{String}" href="#getOpticsKernels-Tuple{String}"><code>getOpticsKernels</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getOpticsKernels(name::String, alpha::Float64 = 1.)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>name</code> - name of a kernel</p></li><li><p><code>alpha</code> - kernel function parameter</p></li></ul><p><strong>Returns:</strong> kernel, function of 2 variables.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/kernels.jl#L9-L20">source</a></section><p>Available kernels:</p><ul><li><code>rectangular</code>:</li></ul><div>\[K(x, y) =
\begin{cases}
1, \text{if } \frac{|x-y|}{\alpha} &lt; 1
\\
0, \text{otherwise}
\end{cases}\]</div><ul><li><code>diffraction</code>:</li></ul><div>\[K(x, y) = \left(\frac{sin(\frac{\pi (x-y)}{s_0})}{\frac{\pi (x-y)}{s_0}}\right)^2\]</div><div>\[s_0 = \frac{\alpha}{0.886}\]</div><ul><li><code>gaussian</code>:</li></ul><div>\[K(x, y) = \frac{2}{\alpha}\sqrt{\frac{\ln2}{\pi}}e^{4\ln2\left(\frac{x-y}{\alpha}\right)^2}\]</div><ul><li><code>triangular</code>:</li></ul><div>\[K(x, y) =
\begin{cases}
\frac{1 - \frac{|x-y|}{\alpha}}{\alpha}, \text{if } \frac{|x-y|}{\alpha} &lt; 1
\\
0, \text{otherwise}
\end{cases}\]</div><ul><li><code>dispersive</code>:</li></ul><div>\[K(x, y) = \frac{\alpha}{2 \pi}\left((x-y)^2 + \left(\frac{\alpha}{2}\right)^2\right)\]</div><ul><li><code>exponential</code>:</li></ul><div>\[K(x, y) = \frac{\ln2}{\alpha}e^{2\ln2\frac{|x-y|}{\alpha}}\]</div><ul><li><code>heaviside</code>:</li></ul><div>\[K(x, y) =
\begin{cases}
1, \text{if } x&gt;0
\\
0, \text{otherwise}
\end{cases}\]</div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="discretize_kernel-Tuple{Basis,Function,Array{Float64,1}}" href="#discretize_kernel-Tuple{Basis,Function,Array{Float64,1}}"><code>discretize_kernel</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">discretize_kernel(basis::Basis, kernel::Function, data_points::Array{Float64, 1})</code></pre><p><strong>Arguments</strong></p><ul><li><code>basis</code> – basis</li><li><code>kernel</code> – <span>$K(x, y)$</span>, kernel</li><li><code>data_points</code> – array of data points</li></ul><p><strong>Returns:</strong> discretized kernel <code>K::Array{Float64, 2}</code>, <span>$K_{mn} = \left(\int_a^b K(x, y) \psi_m(x) dx \right)(y_n)$</span> - matrix of size n<span>$\times$</span>m, where <code>m</code> - number of basis functions, <code>n</code> - number of data points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/basis.jl#L35-L46">source</a></section><h2><a class="nav-anchor" id="Basis-1" href="#Basis-1">Basis</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Basis" href="#Basis"><code>Basis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for all bases.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/basis.jl#L27-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BaseFunction" href="#BaseFunction"><code>BaseFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type for function with its support.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">BaseFunction(f, support::Tuple{Float64,Float64})
BaseFunction(f, a::Float64, b::Float64)</code></pre><p><strong>Fields</strong></p><ul><li><code>f</code> – function (type depends on the basis)</li><li><code>support::Tuple{Float64,Float64}</code> – support of the function</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/basis.jl#L5-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="omega-Tuple{Basis,Int64}" href="#omega-Tuple{Basis,Int64}"><code>omega</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">omega(basis::Basis, order::Int64)</code></pre><p><strong>Arguments</strong></p><ul><li><code>basis</code> - basis</li><li><code>order</code> - order of derivatives</li></ul><p><strong>Returns:</strong> <code>Omega::Array{Float64, 2}</code>, <span>$\Omega_{mn} = \int_a^b \frac{d^{order} \psi_m}{dx^{order}} \frac{d^{order} \psi_n}{dx^{order}}$</span> - matrix of size n<span>$\times$</span>n of the mean values of derivatives of order <code>order</code>, where n - number of functions in basis.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/basis.jl#L67-L77">source</a></section><h3><a class="nav-anchor" id="Fourier-basis-1" href="#Fourier-basis-1">Fourier basis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierBasis" href="#FourierBasis"><code>FourierBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Fourier basis with length <span>$2n+1$</span>: {<span>$0.5$</span>, <span>$\sin(\frac{\pi (x - \frac{a+b}{2})}{b-a})$</span>, <span>$\cos(\frac{\pi (x - \frac{a+b}{2})}{b-a})$</span>, ..., <span>$\sin(\frac{\pi n (x - \frac{a+b}{2})}{b-a})$</span>, <span>$\cos(\frac{\pi n (x - \frac{a+b}{2})}{b-a})$</span>}.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">FourierBasis(a::Float64, b::Float64, n::Int64)</code></pre><p><code>a</code>, <code>b</code> – the beginning and the end of the segment</p><p><code>n</code> – number of basis functions</p><p><strong>Fields</strong></p><ul><li><code>a::Float64</code> – beginning of the support</li><li><code>b::Float64</code> – end of the support</li><li><code>n::Int64</code> – number of basis functions</li><li><code>basis_functions::Array{BaseFunction, 1}</code> – array of basis functions</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/basis.jl#L81-L100">source</a></section><h3><a class="nav-anchor" id="Cubic-Spline-basis-1" href="#Cubic-Spline-basis-1">Cubic Spline basis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CubicSplineBasis" href="#CubicSplineBasis"><code>CubicSplineBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Cubic spline basis - B-spline of the order 3 on given knots with length <span>$n-4$</span>, where n – length of knots array.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">CubicSplineBasis(
    knots::Array{Float64},
    boundary_condition::Union{Tuple{Union{String, Nothing}, Union{String, Nothing}}, Nothing, String}=nothing
    )</code></pre><p><code>knots</code> – knots of spline</p><p><code>boundary_condition</code> – boundary conditions of basis functions. If tuple, the first element affects left bound, the second element affects right bound. If string, both sides are affected. Possible options: <code>&quot;dirichlet&quot;</code>, <code>nothing</code></p><p><strong>Fields</strong></p><ul><li><code>a::Float64</code> – beginning of the support, matches the first element of the array <code>knots</code></li><li><code>b::Float64</code> – end of the support, matches the last element of the array <code>knots</code></li><li><code>knots::Array{Float64, 1}</code> – array of points on which the spline is built</li><li><code>basis_functions::Array{BaseFunction, 1}</code> – array of basis functions</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/basis.jl#L158-L178">source</a></section><h3><a class="nav-anchor" id="Legendre-polynomial-basis-1" href="#Legendre-polynomial-basis-1">Legendre polynomial basis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LegendreBasis" href="#LegendreBasis"><code>LegendreBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Legendre polynomials basis with length <span>$n$</span>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">LegendreBasis(a::Float64, b::Float64, n::Int64)</code></pre><p><code>a</code>, <code>b</code> – the beginning and the end of the support</p><p><code>n</code> – number of basis functions</p><p><strong>Fields</strong></p><ul><li><code>a::Float64</code> – beginning of the support</li><li><code>b::Float64</code> – end of the support</li><li><code>basis_functions::Array{BaseFunction, 1}</code> – array of basis functions</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/basis.jl#L290-L307">source</a></section><h3><a class="nav-anchor" id="Bernstein-polynomial-basis-1" href="#Bernstein-polynomial-basis-1">Bernstein polynomial basis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BernsteinBasis" href="#BernsteinBasis"><code>BernsteinBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Bernstein polynomials basis.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">BernsteinBasis(
    a::Float64, b::Float64, n::Int64,
    boundary_condition::Union{Tuple{Union{String, Nothing}, Union{String, Nothing}}, Nothing, String}=nothing
    )</code></pre><p><code>a</code>, <code>b</code> – the beginning and the end of the segment</p><p><code>n</code> – number of basis functions</p><p><code>boundary_condition</code> – boundary conditions of basis functions. If tuple, the first element affects left bound, the second element affects right bound. If string, both sides are affected. Possible options: <code>&quot;dirichlet&quot;</code>, <code>nothing</code>.</p><p><strong>Fields</strong></p><ul><li><code>a::Float64</code> – beginning of the support</li><li><code>b::Float64</code> – end of the support</li><li><code>basis_functions::Array{BaseFunction, 1}</code> – array of basis functions</li><li><code>boundary_condition::Tuple{Union{String, Nothing}, Union{String, Nothing}}</code> – boundary conditions of basis functions. If tuple, the first element affects left bound, the second element affects right bound. If string, both sides are affected. Possible options: <code>&quot;dirichlet&quot;</code>, <code>nothing</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/basis.jl#L375-L398">source</a></section><h2><a class="nav-anchor" id="Gaussian-noise-distribution-with-alpha-as-argmax-of-posterior-probability-1" href="#Gaussian-noise-distribution-with-alpha-as-argmax-of-posterior-probability-1">Gaussian noise distribution with alpha as argmax of posterior probability</a></h2><h3><a class="nav-anchor" id="Model-1" href="#Model-1">Model</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GaussErrorMatrixUnfolder" href="#GaussErrorMatrixUnfolder"><code>GaussErrorMatrixUnfolder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Model for dicsrete data and kernel.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">GaussErrorMatrixUnfolder(
    omegas::Array{Array{Float64, 2} ,1},
    method::String=&quot;EmpiricalBayes&quot;,
    alphas::Union{Array{Float64, 1}, Nothing}=nothing,
    )</code></pre><p><code>omegas</code> – array of matrices that provide information about basis functions</p><p><code>method</code> – constant selection method, possible options: &quot;EmpiricalBayes&quot; and &quot;User&quot;</p><p><code>alphas</code> – array of constants, in case method=&quot;User&quot; should be provided by user</p><p><code>low</code> – lower limits for alphas</p><p><code>high</code> – higher limits for alphas</p><p><code>alpha0</code> – unitial values for alphas</p><p><strong>Fields</strong></p><ul><li><code>omegas::Array{Array{Float64, 2} ,1}</code></li><li><code>n::Int64</code> – size of square omega matrix</li><li><code>method::String</code></li><li><code>alphas::Union{Array{Float64}, Nothing}</code></li><li><code>low::Union{Array{Float64, 1}, Nothing}</code></li><li><code>high::Union{Array{Float64, 1}, Nothing}</code></li><li><code>alpha0::Union{Array{Float64, 1}, Nothing}</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/gauss_error.jl#L11-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GaussErrorUnfolder" href="#GaussErrorUnfolder"><code>GaussErrorUnfolder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Model for continuous kernel. Data can be either discrete or continuous.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">GaussErrorUnfolder(
    basis::Basis,
    omegas::Array{Array{Float64, 2}, 1},
    method::String=&quot;EmpiricalBayes&quot;,
    alphas::Union{Array{Float64, 1}, Nothing}=nothing,
    low::Union{Array{Float64, 1}, Nothing}=nothing,
    high::Union{Array{Float64, 1}, Nothing}=nothing,
    alpha0::Union{Array{Float64, 1}, Nothing}=nothing
    )</code></pre><p><code>basis</code> – basis for reconstruction</p><p><code>omegas</code> – array of matrices that provide information about basis functions</p><p><code>method</code> – constant selection method, possible options: &quot;EmpiricalBayes&quot; and &quot;User&quot;</p><p><code>alphas</code> – array of constants, in case method=&quot;User&quot; should be provided by user</p><p><code>low</code> – lower limits for alphas</p><p><code>high</code> – higher limits for alphas</p><p><code>alpha0</code> – unitial values for alphas</p><p><strong>Fields</strong></p><ul><li><code>basis::Basis</code></li><li><code>solver::GaussErrorMatrixUnfolder</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/gauss_error.jl#L116-L150">source</a></section><h3><a class="nav-anchor" id="Reconstruction-1" href="#Reconstruction-1">Reconstruction</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="solve-Tuple{GaussErrorMatrixUnfolder,Array{Float64,2},Array{Float64,1},Union{Array{Float64,1}, Array{Float64,2}}}" href="#solve-Tuple{GaussErrorMatrixUnfolder,Array{Float64,2},Array{Float64,1},Union{Array{Float64,1}, Array{Float64,2}}}"><code>solve</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">solve(
    unfolder::GaussErrorMatrixUnfolder,
    kernel::Array{Float64, 2},
    data::Array{Float64, 1},
    data_errors::Union{Array{Float64, 1}, Array{Float64, 2}},
    )</code></pre><p><strong>Arguments</strong></p><ul><li><code>unfolder::GaussErrorMatrixUnfolder</code> – model</li><li><code>kernel::Array{Float64, 2}</code> – discrete kernel</li><li><code>data::Array{Float64, 1}</code> – function values</li><li><code>data_errors::Union{Array{Float64, 1}, Array{Float64, 2}}</code> – function errors</li></ul><p><strong>Returns:</strong> <code>Dict{String, Array{Float64, 1}}</code> with coefficients (&quot;coeff&quot;), errors (&quot;errors&quot;) and optimal constants (&quot;alphas&quot;).</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/gauss_error.jl#L69-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="solve-Tuple{GaussErrorUnfolder,Union{Array{Float64,2}, Function},Union{Array{Float64,1}, Function},Union{Array{Float64,1}, Function},Union{Nothing, Array{Float64,1}}}" href="#solve-Tuple{GaussErrorUnfolder,Union{Array{Float64,2}, Function},Union{Array{Float64,1}, Function},Union{Array{Float64,1}, Function},Union{Nothing, Array{Float64,1}}}"><code>solve</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">solve(
    gausserrorunfolder::GaussErrorUnfolder,
    kernel::Union{Function, Array{Float64, 2}},
    data::Union{Function, Array{Float64, 1}},
    data_errors::Union{Function, Array{Float64, 1}},
    y::Union{Array{Float64, 1}, Nothing},
    )</code></pre><p><strong>Arguments</strong></p><ul><li><code>gausserrorunfolder::GaussErrorUnfolder</code> – model</li><li><code>kernel::Union{Function, Array{Float64, 2}}</code> – discrete or continuous kernel</li><li><code>data::Union{Function, Array{Float64, 1}}</code> – function values</li><li><code>data_errors::Union{Function, Array{Float64, 1}}</code> – function errors</li><li><code>y::Union{Array{Float64, 1}, Nothing}</code> – points to calculate function values and its errors (when data is given as a function)</li></ul><p><strong>Returns:</strong> <code>Dict{String, Array{Float64, 1}}</code> with coefficients (&quot;coeff&quot;), errors (&quot;errors&quot;) and optimal constants (&quot;alphas&quot;).</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/gauss_error.jl#L360-L379">source</a></section><h2><a class="nav-anchor" id="Any-othes-noise-distribution-with-alpha-as-argmax-of-posterior-probability-1" href="#Any-othes-noise-distribution-with-alpha-as-argmax-of-posterior-probability-1">Any othes noise distribution with alpha as argmax of posterior probability</a></h2><h3><a class="nav-anchor" id="Model-2" href="#Model-2">Model</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MCMCMatrixUnfolder" href="#MCMCMatrixUnfolder"><code>MCMCMatrixUnfolder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>MCMC model for dicsrete data and kernel.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">MCMCMatrixUnfolder(
    omegas::Array{Array{Float64, 2} ,1},
    method::String=&quot;EmpiricalBayes&quot;,
    alphas::Union{Array{Float64, 1}, Nothing}=nothing,
    low::Union{Array{Float64, 1}, Nothing}=nothing,
    high::Union{Array{Float64, 1}, Nothing}=nothing,
    alpha0::Union{Array{Float64, 1}, Nothing}=nothing
    )</code></pre><p><code>omegas</code> – array of matrices that provide information about basis functions</p><p><code>method</code> – constant selection method, possible options: &quot;EmpiricalBayes&quot; and &quot;User&quot;</p><p><code>alphas</code> – array of constants, in case method=&quot;User&quot; should be provided by user</p><p><code>low</code> – lower limits for alphas</p><p><code>high</code> – higher limits for alphas</p><p><code>alpha0</code> – unitial values for alphas</p><p><strong>Fields</strong></p><ul><li><code>omegas::Array{Array{Float64, 2} ,1}</code></li><li><code>n::Int64</code> – size of square omega matrix</li><li><code>method::String</code></li><li><code>alphas::Union{Array{Float64}, Nothing}</code></li><li><code>low::Union{Array{Float64, 1}, Nothing}</code></li><li><code>high::Union{Array{Float64, 1}, Nothing}</code></li><li><code>alpha0::Union{Array{Float64, 1}, Nothing}</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/mcmc.jl#L10-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MCMCUnfolder" href="#MCMCUnfolder"><code>MCMCUnfolder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>MCMC model for continuous kernel. Data can be either discrete or continuous.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">MCMCUnfolder(
    basis::Basis,
    omegas::Array{Array{Float64, 2}, 1},
    method::String=&quot;EmpiricalBayes&quot;,
    alphas::Union{Array{Float64, 1}, Nothing}=nothing,
    low::Union{Array{Float64, 1}=nothing,
    high::Union{Array{Float64, 1}, Nothing}=nothing,
    alpha0::Union{Array{Float64, 1}, Nothing}=nothing,
    )</code></pre><p><code>basis</code> – basis for reconstruction</p><p><code>omegas</code> – array of matrices that provide information about basis functions</p><p><code>method</code> – constant selection method, possible options: &quot;EmpiricalBayes&quot; and &quot;User&quot;</p><p><code>alphas</code> – array of constants, in case method=&quot;User&quot; should be provided by user</p><p><strong>Fields</strong></p><ul><li><code>basis::Basis</code></li><li><code>solver::MCMCMatrixUnfolder</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/mcmc.jl#L191-L220">source</a></section><h3><a class="nav-anchor" id="Reconstruction-2" href="#Reconstruction-2">Reconstruction</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="solve" href="#solve"><code>solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">solve(
    mcmcunfolder::MCMCUnfolder,
    kernel::Union{Function, Array{Float64, 2}},
    data::Union{Function, Array{Float64, 1}},
    data_errors::Union{Function, Array{Float64, 1}},
    y::Union{Array{Float64, 1}, Nothing}=nothing,
    chains::Int64 = 1,
    samples::Int64 = 10 * 1000
    )</code></pre><p><strong>Arguments</strong></p><ul><li><code>gausserrorunfolder::GaussErrorUnfolder</code> – model</li><li><code>kernel::Union{Function, Array{Float64, 2}}</code> – discrete or continuous kernel</li><li><code>data::Union{Function, Array{Float64, 1}}</code> – function values</li><li><code>data_errors::Union{Function, Array{Float64, 1}}</code> – function errors</li><li><code>y::Union{Array{Float64, 1}, Nothing}</code> – points to calculate function values and its errors (when data is given as a function)</li><li><code>chains</code> – number of chains for MCMC integration</li><li><code>samples</code> – number of samples for MCMC integration</li></ul><p><strong>Returns:</strong> <code>Dict{String, Array{Float64, 1}}</code> with coefficients (&quot;coeff&quot;) and errors (&quot;errors&quot;).</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/mcmc.jl#L243-L266">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="solve" href="#solve"><code>solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>MCMC solver for dicsrete data and kernel.</p><pre><code class="language-julia">solve(
    unfolder::MCMCMatrixUnfolder,
    kernel::Array{Float64, 2},
    data::Array{Float64, 1},
    data_errors::Union{Array{Float64, 1}, Array{Float64, 2}},
    chains::Int64 = 1,
    samples::Int64 = 10 * 1000
    )</code></pre><p><strong>Arguments</strong></p><ul><li><code>unfolder::MCMCMatrixUnfolder</code> – model</li><li><code>kernel::Array{Float64, 2}</code> – discrete kernel</li><li><code>data::Array{Float64, 1}</code> – function values</li><li><code>data_errors::Union{Array{Float64, 1}, Array{Float64, 2}}</code> – function errors</li><li><code>chains</code> – number of chains for MCMC integration</li><li><code>samples</code> – number of samples for MCMC integration</li></ul><p><strong>Returns:</strong> <code>Dict{String, Array{Float64, 1}}</code> with coefficients (&quot;coeff&quot;) and errors (&quot;errors&quot;).</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/mcmc.jl#L71-L94">source</a></section><h2><a class="nav-anchor" id="Result-1" href="#Result-1">Result</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="get_values-Tuple{ModelChains,Int64,Int64}" href="#get_values-Tuple{ModelChains,Int64,Int64}"><code>get_values</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Allows to get coefficients and errors from generated data set.</p><pre><code class="language-julia">get_values(sim::ModelChains, chains::Int64, n::Int64)</code></pre><p><strong>Arguments</strong></p><ul><li><code>sim::ModelChains</code> – data generated by <code>mcmc()</code></li><li><code>chains::Int64</code> – number of chains</li><li><code>n::Int64</code> – variable list length</li></ul><p><strong>Returns:</strong> <code>Dict{String, Array{Float64, 1}}</code> with coefficients (&quot;coeff&quot;) and errors (&quot;errors&quot;).</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/mcmc.jl#L160-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PhiVec" href="#PhiVec"><code>PhiVec</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Constructs solution function by coefficients, basis and errors.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">PhiVec(coeff::Array{Float64}, basis::Basis, errors::Array{Float64})
PhiVec(coeff::Array{Float64}, basis::Basis)
PhiVec(result::Dict{String, Array{Float64}}, basis::Basis)</code></pre><p><strong>Fields</strong></p><ul><li><code>coeff::Array{Float64}</code> – coefficients of decomposition of a function in basis</li><li><code>basis::Basis</code> – basis</li><li><code>errors::Union{Array{Float64}, Nothing}</code> – coefficients of decomposition of a function errors in basis</li><li><code>phi_function(x::Float64)</code>::Function – returns constructed function&#39;s value at given point</li><li><code>error_function(x::Float64)</code>::Union{Function, Nothing} – returns constructed function&#39;s error at given point,</li></ul><p>if errors are specified, otherwise is <code>nothing</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/13df4cd56a28e276a1a7ffae3999c1aa8fe423cd/src/vector.jl#L5-L24">source</a></section><footer><hr/><a class="previous" href="../getting_started/"><span class="direction">Previous</span><span class="title">Getting started</span></a><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
