<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User&#39;s Guide · StatReg.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StatReg.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../getting_started/">Getting started</a></li><li class="current"><a class="toctext" href>User&#39;s Guide</a><ul class="internal"><li><a class="toctext" href="#Kernel-1">Kernel</a></li><li><a class="toctext" href="#Basis-1">Basis</a></li><li><a class="toctext" href="#Gaussian-noise-distribution-1">Gaussian noise distribution</a></li><li><a class="toctext" href="#Non-Gaussian-noise-distribution-1">Non-Gaussian noise distribution</a></li><li><a class="toctext" href="#Result-1">Result</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>User&#39;s Guide</a></li></ul><a class="edit-page" href="https://github.com/mipt-npm/StatReg.jl/blob/master/docs/src/users_guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>User&#39;s Guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User&#39;s-Guide-1" href="#User&#39;s-Guide-1">User&#39;s Guide</a></h1><h2><a class="nav-anchor" id="Kernel-1" href="#Kernel-1">Kernel</a></h2><p>Kernel can be specified as a matrix or as a function. It is possible to set arbitrary function of 2 variables or use one of predefined kernels.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.getOpticsKernels-Tuple{String}" href="#Main.StatReg.getOpticsKernels-Tuple{String}"><code>Main.StatReg.getOpticsKernels</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getOpticsKernels(name::String, alpha::Real = 1.)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>name</code> - name of a kernel</p></li><li><p><code>alpha</code> - kernel function parameter</p></li></ul><p><strong>Returns:</strong> kernel, function of 2 variables.</p><p>Available kernels:</p><ul><li><code>rectangular</code>:</li></ul><div>\[K(x, y) =
\begin{cases}
1, \text{if } \frac{|x-y|}{\alpha} &lt; 1
\
\text{; } 0 \text{ otherwise}
\end{cases}\]</div><ul><li><code>diffraction</code>:</li></ul><div>\[K(x, y) = \left(\frac{sin(\frac{\pi (x-y)}{s_0})}{\frac{\pi (x-y)}{s_0}}\right)^2\]</div><div>\[s_0 = \frac{\alpha}{0.886}\]</div><ul><li><code>gaussian</code>:</li></ul><div>\[K(x, y) = \frac{2}{\alpha}\sqrt{\frac{\ln2}{\pi}}e^{4\ln2\left(\frac{x-y}{\alpha}\right)^2}\]</div><ul><li><code>triangular</code>:</li></ul><div>\[K(x, y) =
\begin{cases}
\frac{1 - \frac{|x-y|}{\alpha}}{\alpha}, \text{if } \frac{|x-y|}{\alpha} &lt; 1
\
\text{; } 0 \text{ otherwise}
\end{cases}\]</div><ul><li><code>dispersive</code>:</li></ul><div>\[K(x, y) = \frac{\alpha}{2 \pi}\left((x-y)^2 + \left(\frac{\alpha}{2}\right)^2\right)\]</div><ul><li><code>exponential</code>:</li></ul><div>\[K(x, y) = \frac{\ln2}{\alpha}e^{2\ln2\frac{|x-y|}{\alpha}}\]</div><ul><li><code>heaviside</code>:</li></ul><div>\[K(x, y) =
\begin{cases}
1, \text{if } x&gt;0
\
\text{; }  0 \text{ otherwise}
\end{cases}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/kernels.jl#L1-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.discretize_kernel-Tuple{Basis,Function,AbstractArray{#s1020,1} where #s1020&lt;:Real}" href="#Main.StatReg.discretize_kernel-Tuple{Basis,Function,AbstractArray{#s1020,1} where #s1020&lt;:Real}"><code>Main.StatReg.discretize_kernel</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">discretize_kernel(basis::Basis, kernel::Function, data_points::AbstractVector{&lt;:Real})</code></pre><p><strong>Arguments</strong></p><ul><li><code>basis</code> – basis</li><li><code>kernel</code> – kernel function</li><li><code>data_points</code> – array of data points</li></ul><p><strong>Returns:</strong> discretized kernel <code>K::Array{Real, 2}</code>, <span>$K_{mn} = \int\limits_a^b K(x, y_n) \psi_m(x) dx$</span> - matrix of size n<span>$\times$</span>m, where <span>$m$</span> - number of basis functions, <span>$n$</span> - number of data points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/basis.jl#L31-L40">source</a></section><h2><a class="nav-anchor" id="Basis-1" href="#Basis-1">Basis</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.Basis" href="#Main.StatReg.Basis"><code>Main.StatReg.Basis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for all bases.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/basis.jl#L23-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.BaseFunction" href="#Main.StatReg.BaseFunction"><code>Main.StatReg.BaseFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type for function with its support.</p><pre><code class="language-julia">BaseFunction(f, support::Tuple{&lt;:Real,&lt;:Real})
BaseFunction(f, a::Real, b::Real)</code></pre><p><strong>Fields</strong></p><ul><li><code>f</code> – function (type depends on the basis)</li><li><code>support::Tuple{&lt;:Real,&lt;:Real}</code> – support of the function</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/basis.jl#L3-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.omega-Tuple{Basis,Int64}" href="#Main.StatReg.omega-Tuple{Basis,Int64}"><code>Main.StatReg.omega</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">omega(basis::Basis, ord::Int)</code></pre><p><strong>Arguments</strong></p><ul><li><code>basis</code> - basis</li><li><code>ord</code> - order of derivatives</li></ul><p><strong>Returns:</strong> <code>Omega::Array{Real, 2}</code>, <span>$\Omega_{mn} = \int\limits_a^b \frac{d^{ord} \psi_m}{dx^{ord}} \frac{d^{ord} \psi_n}{dx^{ord}}$</span> - matrix of size n<span>$\times$</span>n of the mean values of derivatives of order <code>ord</code>, where n - number of functions in basis.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/basis.jl#L61-L69">source</a></section><h3><a class="nav-anchor" id="Fourier-basis-1" href="#Fourier-basis-1">Fourier basis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.FourierBasis" href="#Main.StatReg.FourierBasis"><code>Main.StatReg.FourierBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Fourier basis with length <span>$2n+1$</span>: {<span>$0.5$</span>, <span>$\sin(\frac{\pi (x - \frac{a+b}{2})}{b-a})$</span>, <span>$\cos(\frac{\pi (x - \frac{a+b}{2})}{b-a})$</span>, ..., <span>$\sin(\frac{\pi n (x - \frac{a+b}{2})}{b-a})$</span>, <span>$\cos(\frac{\pi n (x - \frac{a+b}{2})}{b-a})$</span>}.</p><pre><code class="language-julia">FourierBasis(a::Real, b::Real, n::Int)</code></pre><p><code>a</code>, <code>b</code> – the beginning and the end of the segment <code>n</code> – number of basis functions</p><p><strong>Fields</strong></p><ul><li><code>a::Real</code> – beginning of the support</li><li><code>b::Real</code> – end of the support</li><li><code>n::Int</code> – number of basis functions</li><li><code>basis_functions::AbstractVector{BaseFunction}</code> – array of basis functions</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/basis.jl#L73-L88">source</a></section><h3><a class="nav-anchor" id="Cubic-Spline-basis-1" href="#Cubic-Spline-basis-1">Cubic Spline basis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.CubicSplineBasis" href="#Main.StatReg.CubicSplineBasis"><code>Main.StatReg.CubicSplineBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Cubic spline basis on given knots with length <span>$n$</span>, where n – length of knots array.</p><pre><code class="language-julia">CubicSplineBasis(
    knots::AbstractVector{&lt;:Real},
    boundary_condition::Union{Tuple{Union{String, Nothing}, Union{String, Nothing}}, Nothing, String}=nothing
    )</code></pre><pre><code class="language-julia">CubicSplineBasis(
    a::Real, b::Real, n::Int,
    boundary_condition::Union{Tuple{Union{String, Nothing}, Union{String, Nothing}}, Nothing, String}=nothing
    )</code></pre><p><code>knots</code> – knots of spline <code>boundary_condition</code> – boundary conditions of basis functions. If tuple, the first element affects left bound, the second element affects right bound. If string, both sides are affected. Possible options: <code>&quot;dirichlet&quot;</code>, <code>nothing</code></p><p><strong>Fields</strong></p><ul><li><code>a::Real</code> – beginning of the support, matches the first element of the array <code>knots</code></li><li><code>b::Real</code> – end of the support, matches the last element of the array <code>knots</code></li><li><code>knots::AbstractVector{&lt;:Real}</code> – array of points on which the spline is built</li><li><code>basis_functions::AbstractVector{BaseFunction}</code> – array of basis functions</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/basis.jl#L146-L172">source</a></section><h3><a class="nav-anchor" id="Legendre-polynomials-basis-1" href="#Legendre-polynomials-basis-1">Legendre polynomials basis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.LegendreBasis" href="#Main.StatReg.LegendreBasis"><code>Main.StatReg.LegendreBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Legendre polynomials basis with length <span>$n$</span>.</p><pre><code class="language-julia">LegendreBasis(a::Real, b::Real, n::Int)</code></pre><p><code>a</code>, <code>b</code> – the beginning and the end of the support <code>n</code> – number of basis functions</p><p><strong>Fields</strong></p><ul><li><code>a::Real</code> – beginning of the support</li><li><code>b::Real</code> – end of the support</li><li><code>basis_functions::AbstractVector{BaseFunction}</code> – array of basis functions</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/basis.jl#L290-L305">source</a></section><h3><a class="nav-anchor" id="Bernstein-polynomials-basis-1" href="#Bernstein-polynomials-basis-1">Bernstein polynomials basis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.BernsteinBasis" href="#Main.StatReg.BernsteinBasis"><code>Main.StatReg.BernsteinBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Bernstein polynomials basis.</p><pre><code class="language-julia">BernsteinBasis(
    a::Real, b::Real, n::Int,
    boundary_condition::Union{Tuple{Union{String, Nothing}, Union{String, Nothing}}, Nothing, String}=nothing
    )</code></pre><p><code>a</code>, <code>b</code> – the beginning and the end of the segment <code>n</code> – number of basis functions <code>boundary_condition</code> – boundary conditions of basis functions. If tuple, the first element affects left bound, the second element affects right bound. If string, both sides are affected. Possible options: <code>&quot;dirichlet&quot;</code>, <code>nothing</code>.</p><p><strong>Fields</strong></p><ul><li><code>a::Real</code> – beginning of the support</li><li><code>b::Real</code> – end of the support</li><li><code>basis_functions::AbstractVector{BaseFunction}</code> – array of basis functions</li><li><code>boundary_condition::Tuple{Union{String, Nothing}, Union{String, Nothing}}</code> – boundary conditions of basis functions. If tuple, the first element affects left bound, the second element affects right bound. If string, both sides are affected. Possible options: <code>&quot;dirichlet&quot;</code>, <code>nothing</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/basis.jl#L370-L390">source</a></section><h2><a class="nav-anchor" id="Gaussian-noise-distribution-1" href="#Gaussian-noise-distribution-1">Gaussian noise distribution</a></h2><h3><a class="nav-anchor" id="Model-1" href="#Model-1">Model</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.GaussErrorMatrixUnfolder" href="#Main.StatReg.GaussErrorMatrixUnfolder"><code>Main.StatReg.GaussErrorMatrixUnfolder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Model for discrete data and kernel.</p><pre><code class="language-julia">GaussErrorMatrixUnfolder(
    omegas::Array{Array{T, 2}, 1} where T&lt;:Real,
    method::String=&quot;EmpiricalBayes&quot;;
    alphas::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
    lower::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
    higher::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
    initial::Union{AbstractVector{&lt;:Real}, Nothing}=nothing
    )</code></pre><p><code>omegas</code> – array of matrices that provide information about basis functions</p><p><code>method</code> – constant selection method, possible options: &quot;EmpiricalBayes&quot; and &quot;User&quot;</p><p><code>alphas</code> – array of constants, in case method=&quot;User&quot; should be provided by user</p><p><code>lower</code> – lowerer limits for alphas</p><p><code>higher</code> – higherer limits for alphas</p><p><code>initial</code> – unitial values for alphas</p><p><strong>Fields</strong></p><ul><li><code>omegas::Array{Array{T, 2}, 1} where T&lt;:Real</code></li><li><code>n::Int</code> – size of square omega matrix</li><li><code>method::String</code></li><li><code>alphas::Union{AbstractVector{&lt;:Real}, Nothing}</code></li><li><code>lower::Union{AbstractVector{&lt;:Real}, Nothing}</code></li><li><code>higher::Union{AbstractVector{&lt;:Real}, Nothing}</code></li><li><code>initial::Union{AbstractVector{&lt;:Real}, Nothing}</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/gauss_error.jl#L4-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.GaussErrorUnfolder" href="#Main.StatReg.GaussErrorUnfolder"><code>Main.StatReg.GaussErrorUnfolder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Model for continuous kernel. Data can be either discrete or continuous.</p><pre><code class="language-julia">GaussErrorUnfolder(
    basis::Basis,
    omegas::Array{Array{T, 2}, 1} where T&lt;:Real,
    method::String=&quot;EmpiricalBayes&quot;;
    alphas::Union{AbstractVector{&lt;:Real}, Nothing} =nothing,
    lower::Union{AbstractVector{&lt;:Real}, Nothing} =nothing,
    higher::Union{AbstractVector{&lt;:Real}, Nothing} =nothing,
    initial::Union{AbstractVector{&lt;:Real}, Nothing} =nothing
    )</code></pre><p><code>basis</code> – basis for reconstruction</p><p><code>omegas</code> – array of matrices that provide information about basis functions</p><p><code>method</code> – constant selection method, possible options: &quot;EmpiricalBayes&quot; and &quot;User&quot;</p><p><code>alphas</code> – array of constants, in case method=&quot;User&quot; should be provided by user</p><p><code>lower</code> – lowerer limits for alphas</p><p><code>higher</code> – higherer limits for alphas</p><p><code>initial</code> – unitial values for alphas</p><p><strong>Fields</strong></p><ul><li><code>basis::Basis</code></li><li><code>solver::GaussErrorMatrixUnfolder</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/gauss_error.jl#L112-L146">source</a></section><h3><a class="nav-anchor" id="Reconstruction-1" href="#Reconstruction-1">Reconstruction</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.solve-Tuple{GaussErrorMatrixUnfolder,AbstractArray{#s1020,2} where #s1020&lt;:Real,AbstractArray{#s1019,1} where #s1019&lt;:Real,Union{AbstractArray{#s1018,1}, AbstractArray{#s1018,2}} where #s1018&lt;:Real}" href="#Main.StatReg.solve-Tuple{GaussErrorMatrixUnfolder,AbstractArray{#s1020,2} where #s1020&lt;:Real,AbstractArray{#s1019,1} where #s1019&lt;:Real,Union{AbstractArray{#s1018,1}, AbstractArray{#s1018,2}} where #s1018&lt;:Real}"><code>Main.StatReg.solve</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">solve(
    unfolder::GaussErrorMatrixUnfolder,
    kernel::AbstractMatrix{&lt;:Real},
    data::AbstractVector{&lt;:Real},
    data_errors::AbstractVecOrMat{&lt;:Real}
    )</code></pre><p><strong>Arguments</strong></p><ul><li><code>unfolder</code> – model</li><li><code>kernel</code> – discrete kernel</li><li><code>data</code> – function values</li><li><code>data_errors</code> – function errors</li></ul><p><strong>Returns:</strong> <code>Dict{String, AbstractVector{Real}}</code> with coefficients (&quot;coeff&quot;), errors (&quot;errors&quot;) and optimal constants (&quot;alphas&quot;).</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/gauss_error.jl#L65-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.solve" href="#Main.StatReg.solve"><code>Main.StatReg.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">solve(
    unfolder::GaussErrorUnfolder,
    kernel::Union{Function, AbstractMatrix{&lt;:Real}},
    data::Union{Function, AbstractVector{&lt;:Real}},
    data_errors::Union{Function, AbstractVector{&lt;:Real}},
    y::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
    )</code></pre><p><strong>Arguments</strong></p><ul><li><code>unfolder</code> – model</li><li><code>kernel</code> – discrete or continuous kernel</li><li><code>data</code> – function values</li><li><code>data_errors</code> – function errors</li><li><code>y</code> – points to calculate function values and its errors (when data is given as a function)</li></ul><p><strong>Returns:</strong> `Dict{String, AbstractVector{Real} with coefficients (&quot;coeff&quot;), errors (&quot;errors&quot;) and optimal constants (&quot;alphas&quot;).</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/gauss_error.jl#L169-L188">source</a></section><h2><a class="nav-anchor" id="Non-Gaussian-noise-distribution-1" href="#Non-Gaussian-noise-distribution-1">Non-Gaussian noise distribution</a></h2><h3><a class="nav-anchor" id="Model-2" href="#Model-2">Model</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.MCMCMatrixUnfolder" href="#Main.StatReg.MCMCMatrixUnfolder"><code>Main.StatReg.MCMCMatrixUnfolder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>MCMC model for discrete data and kernel.</p><pre><code class="language-julia">MCMCMatrixUnfolder(
    omegas::Array{Array{T, 2}, 1} where T&lt;:Real,
    method::String=&quot;EmpiricalBayes&quot;;
    alphas::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
    lower::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
    higher::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
    initial::Union{AbstractVector{&lt;:Real}, Nothing}=nothing
    )</code></pre><p><code>omegas</code> – array of matrices that provide information about basis functions</p><p><code>method</code> – constant selection method, possible options: &quot;EmpiricalBayes&quot; and &quot;User&quot;</p><p><code>alphas</code> – array of constants, in case method=&quot;User&quot; should be provided by user</p><p><code>lower</code> – lowerer limits for alphas</p><p><code>higher</code> – higherer limits for alphas</p><p><code>initial</code> – unitial values for alphas</p><p><strong>Fields</strong></p><ul><li><code>omegas::Array{Array{T, 2}, 1} where T&lt;:Real</code></li><li><code>n::Int</code> – size of square omega matrix</li><li><code>method::String</code></li><li><code>alphas::Union{AbstractVector{&lt;:Real}, Nothing}</code></li><li><code>lower::Union{AbstractVector{&lt;:Real}, Nothing}</code></li><li><code>higher::Union{AbstractVector{&lt;:Real}, Nothing}</code></li><li><code>initial::Union{AbstractVector{&lt;:Real}, Nothing}</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/mcmc.jl#L1-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.MCMCUnfolder" href="#Main.StatReg.MCMCUnfolder"><code>Main.StatReg.MCMCUnfolder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>MCMC model for continuous kernel. Data can be either discrete or continuous.</p><pre><code class="language-julia">MCMCUnfolder(
    basis::Basis,
    omegas::Array{Array{T, 2}, 1} where T&lt;:Real,
    method::String=&quot;EmpiricalBayes&quot;;
    alphas::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
    lower::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
    higher::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
    initial::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
    )</code></pre><p><code>basis</code> – basis for reconstruction</p><p><code>omegas</code> – array of matrices that provide information about basis functions</p><p><code>method</code> – constant selection method, possible options: &quot;EmpiricalBayes&quot; and &quot;User&quot;</p><p><code>alphas</code> – array of constants, in case method=&quot;User&quot; should be provided by user</p><p><strong>Fields</strong></p><ul><li><code>basis::Basis</code></li><li><code>solver::MCMCMatrixUnfolder</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/mcmc.jl#L215-L243">source</a></section><h3><a class="nav-anchor" id="Reconstruction-2" href="#Reconstruction-2">Reconstruction</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.solve" href="#Main.StatReg.solve"><code>Main.StatReg.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">solve(
    mcmcunfolder::MCMCUnfolder,
    kernel::Union{Function, AbstractMatrix{&lt;:Real}},
    data::Union{Function, AbstractVector{&lt;:Real}},
    data_errors::Union{Function, AbstractVector{&lt;:Real}},
    y::Union{AbstractVector{&lt;:Real}, Nothing}=nothing;
    model::Union{Model, String} = &quot;Gaussian&quot;,
    samples::Int = 10 * 1000,
    burnin::Int = 0,
    thin::Int = 1,
    chains::Int = 1,
    verbose::Bool = false
    )</code></pre><p><strong>Arguments</strong></p><ul><li><code>unfolder</code> – model</li><li><code>kernel</code> – discrete or continuous kernel</li><li><code>data</code> – function values</li><li><code>data_errors</code> – function errors</li><li><code>y</code> – points to calculate function values and its errors (when data is given as a function)</li><li><code>model</code> – errors model, &quot;Gaussian&quot; or predefined Mamba.jl model</li><li><code>burnin</code>– numer of initial draws to discard as a burn-in sequence to allow for convergence</li><li><code>thin</code> – step-size between draws to output</li><li><code>chains</code>– number of simulation runs to perform</li><li><code>verbose</code> – whether to print sampler progress at the console</li></ul><p><strong>Returns:</strong> parameters for mcmc() function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/mcmc.jl#L267-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.solve-Tuple{MCMCMatrixUnfolder,AbstractArray{#s1020,2} where #s1020&lt;:Real,AbstractArray{#s1019,1} where #s1019&lt;:Real,Union{AbstractArray{#s1018,1}, AbstractArray{#s1018,2}} where #s1018&lt;:Real}" href="#Main.StatReg.solve-Tuple{MCMCMatrixUnfolder,AbstractArray{#s1020,2} where #s1020&lt;:Real,AbstractArray{#s1019,1} where #s1019&lt;:Real,Union{AbstractArray{#s1018,1}, AbstractArray{#s1018,2}} where #s1018&lt;:Real}"><code>Main.StatReg.solve</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>MCMC solver for discrete data and kernel.</p><pre><code class="language-julia">solve(
    unfolder::MCMCMatrixUnfolder,
    kernel::AbstractMatrix{&lt;:Real},
    data::AbstractVector{&lt;:Real},
    data_errors::AbstractVecOrMat{&lt;:Real};
    model::Union{Model, String} = &quot;Gaussian&quot;,
    samples::Int = 10 * 1000,
    burnin::Int = 0,
    thin::Int = 1,
    chains::Int = 1,
    verbose::Bool = false
    )</code></pre><p><strong>Arguments</strong></p><ul><li><code>unfolder</code> – model</li><li><code>kernel</code> – discrete kernel</li><li><code>data</code> – function valuess</li><li><code>data_errors</code> – function errors</li><li><code>model</code> – errors model, &quot;Gaussian&quot; or predefined Mamba.jl model</li><li><code>burnin</code>– numer of initial draws to discard as a burn-in sequence to allow for convergence</li><li><code>thin</code> – step-size between draws to output</li><li><code>chains</code>– number of simulation runs to perform</li><li><code>verbose</code> – whether to print sampler progress at the console</li></ul><p><strong>Returns:</strong> parameters for mcmc() function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/mcmc.jl#L62-L92">source</a></section><h2><a class="nav-anchor" id="Result-1" href="#Result-1">Result</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.get_values" href="#Main.StatReg.get_values"><code>Main.StatReg.get_values</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Allowers to get coefficients and errors from generated data set.</p><pre><code class="language-julia">get_values(sim::ModelChains)</code></pre><p><strong>Arguments</strong></p><ul><li><code>sim</code> – data generated by <code>mcmc()</code></li></ul><p><strong>Returns:</strong> <code>Dict{String, AbstractVector{Real}}</code> with coefficients (&quot;coeff&quot;) and errors (&quot;errors&quot;).</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/mcmc.jl#L184-L196">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.StatReg.PhiVec" href="#Main.StatReg.PhiVec"><code>Main.StatReg.PhiVec</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Constructs solution function by coefficients, basis and errors.</p><pre><code class="language-julia">PhiVec(coeff::Array{&lt;:Real}, basis::Basis, errors::Array{&lt;:Real})
PhiVec(coeff::Array{&lt;:Real}, basis::Basis)
PhiVec(result::Dict{String, Array{&lt;:Real}}, basis::Basis)</code></pre><p><strong>Fields</strong></p><ul><li><code>coeff::Array{&lt;:Real}</code> – coefficients of decomposition of a function in basis</li><li><code>basis::Basis</code> – basis</li><li><code>errors::Union{Array{&lt;:Real}, Nothing}</code> – coefficients of decomposition of a function errors in basis</li><li><code>phi_function(x::Real)</code>::Function – returns constructed function&#39;s value at given point</li><li><code>error_function(x::Real)</code>::Union{Function, Nothing} – returns constructed function&#39;s error at given point, if errors are specified, otherwise is <code>nothing</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/StatReg.jl/blob/88aa81d0529b21bb20acfdda3ecfbc8b932d2bde/src/vector.jl#L1-L19">source</a></section><footer><hr/><a class="previous" href="../getting_started/"><span class="direction">Previous</span><span class="title">Getting started</span></a><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
