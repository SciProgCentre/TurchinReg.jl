<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User&#39;s Guide · TurchinReg.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TurchinReg.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../getting_started/">Getting started</a></li><li class="current"><a class="toctext" href>User&#39;s Guide</a><ul class="internal"><li><a class="toctext" href="#Kernel-1">Kernel</a></li><li><a class="toctext" href="#Bases-1">Bases</a></li><li><a class="toctext" href="#Parameters-of-reconstruction-algorithm-1">Parameters of reconstruction algorithm</a></li><li><a class="toctext" href="#Reconstruction-1">Reconstruction</a></li><li><a class="toctext" href="#Result-1">Result</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>User&#39;s Guide</a></li></ul><a class="edit-page" href="https://github.com/mipt-npm/TurchinReg.jl/blob/master/docs/src/users_guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>User&#39;s Guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User&#39;s-Guide-1" href="#User&#39;s-Guide-1">User&#39;s Guide</a></h1><h2><a class="nav-anchor" id="Kernel-1" href="#Kernel-1">Kernel</a></h2><p>Kernel can be specified as a matrix or as a function. It is possible to set arbitrary function of 2 variables or use one of predefined kernels.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.getOpticsKernels-Tuple{String}" href="#Main.TurchinReg.getOpticsKernels-Tuple{String}"><code>Main.TurchinReg.getOpticsKernels</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getOpticsKernels(name::String, alpha::Real = 1.)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>name</code> - name of a kernel</p></li><li><p><code>alpha</code> - kernel function parameter</p></li></ul><p><strong>Returns:</strong> kernel, function of 2 variables.</p><p>Available kernels:</p><ul><li><code>rectangular</code>:</li></ul><div>\[K(x, y) =
\begin{cases}
1, \text{if } \frac{|x-y|}{\alpha} &lt; 1
\
\text{; } 0 \text{ otherwise}
\end{cases}\]</div><ul><li><code>diffraction</code>:</li></ul><div>\[K(x, y) = \left(\frac{sin(\frac{\pi (x-y)}{s_0})}{\frac{\pi (x-y)}{s_0}}\right)^2\]</div><div>\[s_0 = \frac{\alpha}{0.886}\]</div><ul><li><code>gaussian</code>:</li></ul><div>\[K(x, y) = \frac{2}{\alpha}\sqrt{\frac{\ln2}{\pi}}e^{4\ln2\left(\frac{x-y}{\alpha}\right)^2}\]</div><ul><li><code>triangular</code>:</li></ul><div>\[K(x, y) =
\begin{cases}
\frac{1 - \frac{|x-y|}{\alpha}}{\alpha}, \text{if } \frac{|x-y|}{\alpha} &lt; 1
\
\text{; } 0 \text{ otherwise}
\end{cases}\]</div><ul><li><code>dispersive</code>:</li></ul><div>\[K(x, y) = \frac{\alpha}{2 \pi}\left((x-y)^2 + \left(\frac{\alpha}{2}\right)^2\right)\]</div><ul><li><code>exponential</code>:</li></ul><div>\[K(x, y) = \frac{\ln2}{\alpha}e^{2\ln2\frac{|x-y|}{\alpha}}\]</div><ul><li><code>heaviside</code>:</li></ul><div>\[K(x, y) =
\begin{cases}
1, \text{if } x&gt;0
\
\text{; }  0 \text{ otherwise}
\end{cases}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/solution_utils/kernels.jl#L1-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.discretize_kernel-Tuple{Basis,Function,AbstractArray{#s405,1} where #s405&lt;:Real}" href="#Main.TurchinReg.discretize_kernel-Tuple{Basis,Function,AbstractArray{#s405,1} where #s405&lt;:Real}"><code>Main.TurchinReg.discretize_kernel</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">discretize_kernel(basis::Basis, kernel::Function, measurement_points::AbstractVector{&lt;:Real})</code></pre><p><strong>Arguments</strong></p><ul><li><code>basis</code> – basis</li><li><code>kernel</code> – kernel function</li><li><code>measurement_points</code> – array of data points</li></ul><p><strong>Returns:</strong> discretized kernel <code>K::Array{Real, 2}</code>, <span>$K_{mn} = \int\limits_a^b K(x, y_n) \psi_m(x) dx$</span> - matrix of size n<span>$\times$</span>m, where <span>$m$</span> - number of basis functions, <span>$n$</span> - number of data points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/bases/utils.jl#L7-L16">source</a></section><h2><a class="nav-anchor" id="Bases-1" href="#Bases-1">Bases</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.Basis" href="#Main.TurchinReg.Basis"><code>Main.TurchinReg.Basis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for all bases.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/bases/utils.jl#L1-L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.omega-Tuple{Basis,Int64}" href="#Main.TurchinReg.omega-Tuple{Basis,Int64}"><code>Main.TurchinReg.omega</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">omega(basis::Basis, order::Int)</code></pre><p><strong>Arguments</strong></p><ul><li><code>basis</code> - basis</li><li><code>order</code> - order of derivatives</li></ul><p><strong>Returns:</strong> <code>Omega::Array{Real, 2}</code>, <span>$\Omega_{mn} = \int\limits_a^b \frac{d^{order} \psi_m}{dx^{order}} \frac{d^{order} \psi_n}{dx^{order}}$</span> - matrix of size n<span>$\times$</span>n of the mean values of derivatives of order <code>order</code>, where n - number of functions in basis.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/bases/utils.jl#L37-L45">source</a></section><h3><a class="nav-anchor" id="Fourier-basis-1" href="#Fourier-basis-1">Fourier basis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.FourierBasis" href="#Main.TurchinReg.FourierBasis"><code>Main.TurchinReg.FourierBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Fourier basis with length <span>$2n+1$</span>: {<span>$0.5$</span>, <span>$\sin(\frac{\pi (x - \frac{a+b}{2})}{b-a})$</span>, <span>$\cos(\frac{\pi (x - \frac{a+b}{2})}{b-a})$</span>, ..., <span>$\sin(\frac{\pi n (x - \frac{a+b}{2})}{b-a})$</span>, <span>$\cos(\frac{\pi n (x - \frac{a+b}{2})}{b-a})$</span>}.</p><pre><code class="language-julia">FourierBasis(a::Real, b::Real, n::Int)</code></pre><p><code>a</code>, <code>b</code> – the beginning and the end of the segment <code>n</code> – number of harmonics</p><p><strong>Fields</strong></p><ul><li><code>a::Real</code> – beginning of the support</li><li><code>b::Real</code> – end of the support</li><li><code>n::Int</code> – number of harmonics</li><li><code>basis_functions::AbstractVector</code> – array of basis functions</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/bases/fourier.jl#L1-L16">source</a></section><h3><a class="nav-anchor" id="Cubic-Spline-basis-1" href="#Cubic-Spline-basis-1">Cubic Spline basis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.CubicSplineBasis" href="#Main.TurchinReg.CubicSplineBasis"><code>Main.TurchinReg.CubicSplineBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Cubic spline basis on given knots with length <span>$n$</span>.</p><pre><code class="language-julia">CubicSplineBasis(
    knots::AbstractVector{&lt;:Real},
    boundary_condition::Union{Tuple{Union{String, Nothing}, Union{String, Nothing}}, Nothing, String}=nothing
    )</code></pre><pre><code class="language-julia">CubicSplineBasis(
    a::Real, b::Real, n::Int,
    boundary_condition::Union{Tuple{Union{String, Nothing}, Union{String, Nothing}}, Nothing, String}=nothing
    )</code></pre><p><code>knots</code> – knots of spline <code>boundary_condition</code> – boundary conditions of basis functions. If tuple, the first element affects left bound, the second element affects right bound. If string, both sides are affected. Possible options: <code>&quot;dirichlet&quot;</code>, <code>nothing</code></p><p><strong>Fields</strong></p><ul><li><code>a::Real</code> – beginning of the support, matches the first element of the array <code>knots</code></li><li><code>b::Real</code> – end of the support, matches the last element of the array <code>knots</code></li><li><code>knots::AbstractVector{&lt;:Real}</code> – array of points on which the spline is built</li><li><code>basis_functions::AbstractVector</code> – array of basis functions</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/bases/cubic_spline.jl#L1-L27">source</a></section><h3><a class="nav-anchor" id="Legendre-polynomials-basis-1" href="#Legendre-polynomials-basis-1">Legendre polynomials basis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.LegendreBasis" href="#Main.TurchinReg.LegendreBasis"><code>Main.TurchinReg.LegendreBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Legendre polynomials basis with length <span>$n$</span>.</p><pre><code class="language-julia">LegendreBasis(a::Real, b::Real, n::Int)</code></pre><p><code>a</code>, <code>b</code> – the beginning and the end of the support <code>n</code> – number of basis functions</p><p><strong>Fields</strong></p><ul><li><code>a::Real</code> – beginning of the support</li><li><code>b::Real</code> – end of the support</li><li><code>basis_functions::AbstractVector{BaseFunction}</code> – array of basis functions</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/bases/legendre.jl#L1-L16">source</a></section><h3><a class="nav-anchor" id="Bernstein-polynomials-basis-1" href="#Bernstein-polynomials-basis-1">Bernstein polynomials basis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.BernsteinBasis" href="#Main.TurchinReg.BernsteinBasis"><code>Main.TurchinReg.BernsteinBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Bernstein polynomials basis.</p><pre><code class="language-julia">BernsteinBasis(
    a::Real, b::Real, n::Int,
    boundary_condition::Union{Tuple{Union{String, Nothing}, Union{String, Nothing}}, Nothing, String}=nothing
    )</code></pre><p><code>a</code>, <code>b</code> – the beginning and the end of the segment <code>n</code> – number of basis functions <code>boundary_condition</code> – boundary conditions of basis functions. If tuple, the first element affects left bound, the second element affects right bound. If string, both sides are affected. Possible options: <code>&quot;dirichlet&quot;</code>, <code>nothing</code>.</p><p><strong>Fields</strong></p><ul><li><code>a::Real</code> – beginning of the support</li><li><code>b::Real</code> – end of the support</li><li><code>basis_functions::AbstractVector{Function}</code> – array of basis functions</li><li><code>boundary_condition::Tuple{Union{String, Nothing}, Union{String, Nothing}}</code> – boundary conditions of basis functions. Possible options: <code>&quot;dirichlet&quot;</code>, <code>nothing</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/bases/bernstein.jl#L1-L21">source</a></section><h2><a class="nav-anchor" id="Parameters-of-reconstruction-algorithm-1" href="#Parameters-of-reconstruction-algorithm-1">Parameters of reconstruction algorithm</a></h2><h3><a class="nav-anchor" id="Regularization-parameters-1" href="#Regularization-parameters-1">Regularization parameters</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.AlphasType" href="#Main.TurchinReg.AlphasType"><code>Main.TurchinReg.AlphasType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for all algorithms for choosing regularization parameters</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/utils/structures.jl#L5-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.ArgmaxBAT" href="#Main.TurchinReg.ArgmaxBAT"><code>Main.TurchinReg.ArgmaxBAT</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><span>$alphas = argmax(P(alphas|f))$</span> Mode of the distribution is found by sampling using BAT.jl</p><pre><code class="language-julia">ArgmaxBAT(alphas::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
lower::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
higher::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
initial::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
algo::MCMCAlgorithm=MetropolisHastings(),
nchains::Int=2,
nsamples::Int=1e4,
)</code></pre><p><strong>Fields</strong></p><ul><li><code>alphas::Union{AbstractVector{&lt;:Real}, Nothing}</code> – values of regularization parameters</li><li><code>lower::Union{AbstractVector{&lt;:Real}, Nothing}</code> – lower possible values of regularization parameters</li><li><code>higher::Union{AbstractVector{&lt;:Real}, Nothing}</code> – higher possible values of regularization parameters</li><li><code>initial::Union{AbstractVector{&lt;:Real}, Nothing}</code> – initial values of regularization parameters</li><li><code>algo::MCMCAlgorithm</code> – algorithm of sampling (for more info see BAT.jl documentation)</li><li><code>nchains::Int</code> – number of chains to sample</li><li><code>nsamples::Int</code> – number of samples</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/utils/structures.jl#L11-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.ArgmaxOptim" href="#Main.TurchinReg.ArgmaxOptim"><code>Main.TurchinReg.ArgmaxOptim</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><span>$alphas = argmax(P(alphas|f))$</span> Mode of the distribution is found by sampling using Optim.jl</p><pre><code class="language-julia">ArgmaxOptim(alphas::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
lower::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
higher::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
initial::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
algo=BFGS()
)</code></pre><p><strong>Fields</strong></p><ul><li><code>alphas::Union{AbstractVector{&lt;:Real}, Nothing}</code> – values of regularization parameters</li><li><code>lower::Union{AbstractVector{&lt;:Real}, Nothing}</code> – lower possible values of regularization parameters</li><li><code>higher::Union{AbstractVector{&lt;:Real}, Nothing}</code> – higher possible values of regularization parameters</li><li><code>initial::Union{AbstractVector{&lt;:Real}, Nothing}</code> – initial values of regularization parameters</li><li><code>algo</code> – algorithm of optimization (for more info see Optim.jl documentation)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/utils/structures.jl#L54-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.Marginalize" href="#Main.TurchinReg.Marginalize"><code>Main.TurchinReg.Marginalize</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Allows to compute <span>$\varphi$</span> averaging over all parameters</p><pre><code class="language-julia">Marginalize()</code></pre><p><strong>Fields</strong></p><ul><li><code>alphas::Nothing</code> – no fixed regularization parameters</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/utils/structures.jl#L92-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.User" href="#Main.TurchinReg.User"><code>Main.TurchinReg.User</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>User-defined parameters</p><pre><code class="language-julia">User(alphas::AbstractVector{&lt;:Real})</code></pre><p><strong>Fields</strong></p><ul><li><code>alphas::AbstractVector{&lt;:Real}</code> – fixed regularization parameters</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/utils/structures.jl#L112-L121">source</a></section><h3><a class="nav-anchor" id="Reconstruction-algorithms-1" href="#Reconstruction-algorithms-1">Reconstruction algorithms</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.AlgoType" href="#Main.TurchinReg.AlgoType"><code>Main.TurchinReg.AlgoType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for all solution algorithms</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/utils/structures.jl#L169-L171">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.Analytically" href="#Main.TurchinReg.Analytically"><code>Main.TurchinReg.Analytically</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Analytical solution</p><pre><code class="language-julia">Analytically()</code></pre><p><strong>Fields</strong> no fields</p></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/utils/structures.jl#L174-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.BATSampling" href="#Main.TurchinReg.BATSampling"><code>Main.TurchinReg.BATSampling</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Solve with BATSampling</p><pre><code class="language-julia">BATSampling(log_data_distribution::Union{Function, Nothing}=nothing,
algo::MCMCAlgorithm=MetropolisHastings(),
nchains::Int=2,
nsamples::Int=1e4
)</code></pre><p><strong>Fields</strong></p><ul><li><code>log_data_distribution::Union{Function, Nothing}</code> – logarithm of data distribution</li><li><code>algo::MCMCAlgorithm</code> – algorithm foe sampling (foe more info see BAT.jlj documentation)</li><li><code>nchains::Int</code> – number of chains to sample</li><li><code>nsamples::Int</code> – number of samples</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/utils/structures.jl#L186-L202">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.AHMCSampling" href="#Main.TurchinReg.AHMCSampling"><code>Main.TurchinReg.AHMCSampling</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Solve with AHMCSampling</p><pre><code class="language-julia">AHMCSampling(log_data_distribution::Union{Function, Nothing}=nothing,
nchains::Int=1,
nsamples::Int=1e4
)</code></pre><p><strong>Fields</strong></p><ul><li><code>log_data_distribution::Union{Function, Nothing}</code> – logarithm of data distribution</li><li><code>nchains::Int</code> – number of chains to sample</li><li><code>nsamples::Int</code> – number of samples</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/utils/structures.jl#L217-L231">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.DHMCSampling" href="#Main.TurchinReg.DHMCSampling"><code>Main.TurchinReg.DHMCSampling</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Solve with DHMCSampling</p><pre><code class="language-julia">DHMCSampling(log_data_distribution::Union{Function, Nothing}=nothing,
nchains::Int=1,
nsamples::Int=1e4
)</code></pre><p><strong>Fields</strong></p><ul><li><code>log_data_distribution::Union{Function, Nothing}</code> – logarithm of data distribution</li><li><code>nchains::Int</code> – number of chains to sample</li><li><code>nsamples::Int</code> – number of samples</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/utils/structures.jl#L246-L260">source</a></section><h2><a class="nav-anchor" id="Reconstruction-1" href="#Reconstruction-1">Reconstruction</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.solve" href="#Main.TurchinReg.solve"><code>Main.TurchinReg.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Solve the problem</p><pre><code class="language-julia">solve(
    basis::Basis,
    data::Union{AbstractVector{&lt;:Real}, Function},
    data_errors::Union{AbstractVecOrMat{&lt;:Real}, Function},
    kernel::Union{Function, AbstractMatrix{&lt;:Real}},
    measurement_points::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
    algo::AlgoType=Analytically(),
    alphas::AlphasType=ArgmaxBAT(),
    omegas::Union{Array{Array{T, 2}, 1}, Nothing} where T&lt;:Real = nothing,
    phi_bounds::PhiBounds=PhiBounds(),
    )</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/solvers/solve.jl#L1-L17">source</a></section><h2><a class="nav-anchor" id="Result-1" href="#Result-1">Result</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Main.TurchinReg.PhiVec" href="#Main.TurchinReg.PhiVec"><code>Main.TurchinReg.PhiVec</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Constructs solution function by coefficients, basis and errors.</p><pre><code class="language-julia">PhiVec(coeff::Array{&lt;:Real}, basis::Basis, errors::Array{&lt;:Real})</code></pre><pre><code class="language-julia">PhiVec(coeff::Array{&lt;:Real}, basis::Basis)</code></pre><pre><code class="language-julia">PhiVec(result::Dict{String, Array{&lt;:Real}}, basis::Basis)</code></pre><p><strong>Fields</strong></p><ul><li><code>coeff::Array{&lt;:Real}</code> – coefficients of decomposition of a function in basis</li><li><code>basis::Basis</code> – basis</li><li><code>errors::Union{Array{&lt;:Real}, Nothing}</code> – coefficients of decomposition of a function errors in basis</li><li><code>solution_function(x::Real)</code>::Function – returns constructed function&#39;s value at given point</li><li><code>error_function(x::Real)</code>::Union{Function, Nothing} – returns constructed function&#39;s error at given point, if errors are specified, otherwise is <code>nothing</code></li><li><code>alphas::Union{AbstractVector{&lt;:Real}, Nothing}</code> – list of regularization parameters</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/mipt-npm/TurchinReg.jl/blob/c5079ff5ef7ab1cb6dc5c851663378e764aec72d/src/solution_utils/vector.jl#L1-L26">source</a></section><footer><hr/><a class="previous" href="../getting_started/"><span class="direction">Previous</span><span class="title">Getting started</span></a><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
